1
00:00:00,333 --> 00:00:06,333
[Music]

2
00:00:17,483 --> 00:00:18,466
>> Bienvenidos de nuevo, amigos.

3
00:00:19,183 --> 00:00:22,466
Gracias por unirte Tobias y a mi mismo, mientras caminamos a través de consultas

4
00:00:22,483 --> 00:00:27,166
SQL Server 2012 y tratando mostrarles algunos pequeños tips

5
00:00:27,483 --> 00:00:29,466
y trucos para obtener el máximo rendimieto de sus bases de datos en SQL

6
00:00:29,483 --> 00:00:33,433
Server 2012. Vamos a pasar otro módulo aquí, así que

7
00:00:33,483 --> 00:00:36,466
vamos a estar hablando de agregacion o agrupamiento y agregacion de datos.

8
00:00:37,483 --> 00:00:39,466
Hemos pasado por algunos... más o menos cierta fundamental, alguna

9
00:00:39,483 --> 00:00:43,466
información básica acerca de SQL Server, estamos hablando el tipo de, otra vez,

10
00:00:43,233 --> 00:00:45,433
nivelar el campo de juego. Vamos a introducir algunos de loas avanzadas

11
00:00:45,483 --> 00:00:48,466
estados seleccionados. Hablamos acerca de SQL Server tipos de datos dentro de

12
00:00:48,483 --> 00:00:50,466
modelo previo y la importancia de como vas a crear

13
00:00:50,483 --> 00:00:53,466
tus objetos y comprender como ellos van a ser usados.

14
00:00:53,483 --> 00:00:57,466
Lo que vamos a hacer ahora está viendo para agregar funciones.

15
00:00:57,483 --> 00:01:00,466
Yo llamé molesto porque aveces tiene que ser de esa manera.

16
00:01:00,483 --> 00:01:04,466
O y tanto como la agrupación por o grupo por y que tiene cláusulas.

17
00:01:04,483 --> 00:01:08,466
Hablaremos de subconsultas, al mismo tiempo todo el mismo-contenido, correlacioando

18
00:01:08,483 --> 00:01:13,466
y existente. Y vamos a echar un vistazo a una vista , creando una vista

19
00:01:13,483 --> 00:01:15,466
Y vamos a ver algunas de estas tablas. Hemos tenido algunas preguntas

20
00:01:15,483 --> 00:01:19,350
en los cuadros de línea y tablas de derivadas. Hablaremos de esto

21
00:01:19,433 --> 00:01:22,466
en esta sección. Por tanto vamos a dirigirnos directamente en a esto

22
00:01:22,483 --> 00:01:27,466
y tener una conversación para comenzar con en las funciones de agregado.

23
00:01:27,483 --> 00:01:30,466
Y hay tres categorías de estas funciones. Están las 

24
00:01:30,483 --> 00:01:33,466
comunes que vamos a ver como la suma y el mínimo, máximo, 

25
00:01:33,483 --> 00:01:36,466
la cuenta promedio. Tenemos algunas de estas estadísticas.

26
00:01:36,483 --> 00:01:39,433
Y para el viernes el 13 me alegro de que era capaz de decir esto.

27
00:01:40,483 --> 00:01:43,466
Desviación estándar, por ejemplo y tenemos el var, var

28
00:01:43,483 --> 00:01:47,233
P, Y tenemos algunas otras como la Agrupación y agrupación de ID

29
00:01:47,316 --> 00:01:51,466
esto está disponible para nosotros también. Así que tenemos estas categorías

30
00:01:51,483 --> 00:01:54,316
de funciones de agregado que tenemos a nuestra disposición.

31
00:01:55,483 --> 00:01:59,400
Si comenzamos a trabajar con funciones agregadas, devuelven un valor

32
00:01:59,483 --> 00:02:03,316
escalar sin el título de la columna. Van a ignorar nulos la mayoría

33
00:02:03,400 --> 00:02:06,466
del tiempo con excepción de la cuenta. Pueden utilizarse

34
00:02:06,483 --> 00:02:10,466
en la instrucción select y el orden de las cláusulas.

35
00:02:10,483 --> 00:02:12,466
Son frecuentemente utilizados con la cláusula group by. Y tenemos

36
00:02:12,483 --> 00:02:18,466
un ejemplo de una cuenta seleccione, ID de pedido de ventas distintas como 

37
00:02:18,483 --> 00:02:22,466
órdenes singulares, y tenemos precio unitario promedio como un nombre de columna.

38
00:02:22,483 --> 00:02:26,466
Minuto... o cantidad de orden mínima. Y tenemos el total de la línea máximo

39
00:02:26,483 --> 00:02:29,466
para un elemento determinado de la línea. Y recuperamos esta

40
00:02:29,483 --> 00:02:32,466
información de la mesa del detalle de pedido de ventas. Y como se puede

41
00:02:32,483 --> 00:02:35,466
ver un ejemplo de los resultados son en el fondo aquí donde

42
00:02:35,216 --> 00:02:40,466
tenemos 31.465 órdenes singulares. El precio unitario promedio es de $465. 

43
00:02:40,483 --> 00:02:43,466
Conseguimos esto del promedio allí. La cantidad

44
00:02:43,483 --> 00:02:47,466
de orden mínima es 1.  Espero que no exista un detalle de la orden de línea

45
00:02:47,483 --> 00:02:50,466
detallada para la cantidad de orden 0, así que me alegré de ver que 1.

46
00:02:51,483 --> 00:02:53,466
Y entonces hicimos un máximo total de la línea es 27,893.619000.

47
00:02:57,483 --> 00:03:02,466
Así conseguimos un retrievalable de contenido de... contiene 

48
00:03:02,483 --> 00:03:06,466
 funciones de agregado de cuatro en una declaración que 

49
00:03:06,483 --> 00:03:11,383
hace agradable así que podemos resumir que el contenido y tipo de darnos una pantalla

50
00:03:11,483 --> 00:03:15,466
en vez de buscar en 31.000 registros, además de determinar lo que está

51
00:03:15,483 --> 00:03:19,466
sucediendo con el número de elementos en los... en la mesa de información.

52
00:03:20,483 --> 00:03:22,466
La cláusula distinta, hablamos de esto. Hemos introducido

53
00:03:22,483 --> 00:03:26,466
un par de veces con funciones de agregado, proporciona ese 

54
00:03:26,483 --> 00:03:27,466
resumen de la información.

55
00:03:28,316 --> 00:03:32,466
Agrega, pero durante la agregación elimina 

56
00:03:32,483 --> 00:03:37,466
duplicate values, not rows, but it eliminates the informationaquellos valores duplicados, no filas, pero elimina la información 

57
00:03:37,233 --> 00:03:40,466
que sería normalmente proporcionada. Y tenemos un ejemplo aquí otra vez.

58
00:03:40,483 --> 00:03:44,466
Estamos haciendo un recuento en distintos ID de cliente y estamos utilizando esa 

59
00:03:44,483 --> 00:03:47,466
información y luego devolver información sobre el vendedor 

60
00:03:47,483 --> 00:03:51,466
ID, el fin del año, todos los clientes y de los clientes.

61
00:03:51,483 --> 00:03:55,466
Por tanto tratamos de averiguar por dependiente cuantos 

62
00:03:55,483 --> 00:03:59,466
clientes tienen en conjunto y por año cuántos clientes únicos que habían.

63
00:03:59,483 --> 00:04:04,466
Así que esto es lo que esta... la consulta haremos para usted con esta 

64
00:04:04,483 --> 00:04:06,466
función de agregado en la cláusula distinta.

65
00:04:06,483 --> 00:04:10,366
>> Okay. Me gustaría simplemente lanzar algo aquí para clase de eliminar la ambigüedad 


66
00:04:10,450 --> 00:04:14,466
de un poco más entre las varias cosas que puedes usar. Y otra vez

67
00:04:14,483 --> 00:04:15,466
Pido disculpas por

68
00:04:16,483 --> 00:04:17,466
lo que mi...

69
00:04:17,483 --> 00:04:19,466
>> Su monitor lo espanto?

70
00:04:19,483 --> 00:04:20,366
>> Si, si.

71
00:04:20,450 --> 00:04:21,466
>> Es como volver.

72
00:04:21,483 --> 00:04:23,433
>> Salí del sistema y luego estaba todo bien.

73
00:04:23,450 --> 00:04:23,466
>> Okay.

74
00:04:23,483 --> 00:04:28,266
>> Tan sólo mirar esto distintos y agregados y agrupar por,

75
00:04:28,350 --> 00:04:34,466
digamos, sólo obtengo todos los pedidos.

76
00:04:35,433 --> 00:04:43,466
A la derecha? Allí nos dirigimos. Ahora quiero llegar a...

77
00:04:44,483 --> 00:04:49,466
vamos a decir a lo que quiero llegar es que quiero conseguir realmente máximo 

78
00:04:49,483 --> 00:04:52,466
de una orden por cliente. SAsí que estoy interesado en esta cosa distinta 

79
00:04:52,483 --> 00:04:56,466
por cliente. Por lo tanto, tratar y calcular. Tan sólo 

80
00:04:56,483 --> 00:04:58,466
voy a hacer recuento, distintos 

81
00:04:59,483 --> 00:05:02,466
ID de cliente. Así pues, ahora sabremos,bueno, esta es la forma en que muchos clientes están 

82
00:05:02,483 --> 00:05:08,216
referenciados en esta tabla. Okay. Hasta 19.000 algo.

83
00:05:09,483 --> 00:05:14,166
What if I now want to have 19,000 rows returned but I only...

84
00:05:14,250 --> 00:05:16,466
Qué pasa si ahora quiero tener 19.000 filas devueltas pero sólo...

85
00:05:16,483 --> 00:05:17,466
>> Derecha.

86
00:05:17,483 --> 00:05:20,466
>> Pero también quiero otra información. Por tanto puedo intentar y realmente me agrupo 

87
00:05:20,483 --> 00:05:25,466
por y digamos, bien, me doy al cliente... me da todo 

88
00:05:25,483 --> 00:05:27,466
y quiere este grupo por ID de cliente.

89
00:05:29,166 --> 00:05:31,466
¿Bien, esto no... no tiene mucho sentido, correcto?

90
00:05:31,483 --> 00:05:36,0
Como ahora dice calculan algún conjunto para cada cliente.

91
00:05:36,483 --> 00:05:40,466
Por tanto espero recuperar una fila por cliente pero devolvemos detalles.

92
00:05:40,483 --> 00:05:43,466
¿Verdad? No estamos usando agregados. Por tanto podría decir entonces, bien, 

93
00:05:43,483 --> 00:05:45,466
déme sólo al cliente ID atrás.

94
00:05:47,483 --> 00:05:50,466
Y ahora voy a solo un ID de cliente y puedo decir uso un agregado 
95
00:05:50,483 --> 00:05:53,466
estrella o algo para obtener el número de filas. Pero yo

96
00:05:53,483 --> 00:05:55,466
quiero los detalles en este caso.

97
00:05:55,483 --> 00:05:59,466
Si intento y uso distinto sobre esto, entonces obviamente lo hace distinto

98
00:06:00,483 --> 00:06:01,466
a lo largo de toda la fila.
 
99
00:06:01,483 --> 00:06:04,466
Lo que puedo hacer es utilizar esta cosa número de fila que es muy interesante 

100
00:06:04,483 --> 00:06:09,466
para este problema. De este modo, otra vez, lo que busco es darme una orden

101
00:06:09,483 --> 00:06:13,166
por clientes. Así que básicamente el orden primero o el último para cada cliente.

102
00:06:13,250 --> 00:06:14,466
Pero quiero todos los detalles de la orden.

103
00:06:15,483 --> 00:06:21,333
Así que digo estrellas seleccione encabezado de pedido de ventas, y a decir,
104
00:06:21,483 --> 00:06:23,466
 bueno, por favor calcula ahora el número de fila

105
00:06:26,483 --> 00:06:28,466
sobre la partición por

106
00:06:30,250 --> 00:06:34,316
Así que básicamente empezar a contar otra vez cuando es un nuevo 

107
00:06:34,400 --> 00:06:39,466
ID de cliente. Y ordenar por... digamos que quiero que los nuevos pedidos, 

108
00:06:39,483 --> 00:06:42,466
así que quiero el último pedido del cliente...

109
00:06:42,183 --> 00:06:42,466
>> Verdad....

110
00:06:42,483 --> 00:06:44,466
>> como el número de fila.

111
00:06:44,483 --> 00:06:50,466
Okay? Por tanto esto ejecutaría sólo y calcularía los números de fila 

112
00:06:50,483 --> 00:06:55,466
para mí. Ahora, qué pasa si sólo quiero tener ahora la primera de cada 

113
00:06:55,483 --> 00:07:00,466
orden, diría algo como, bien, me da que ya sé que 

114
00:07:00,483 --> 00:07:04,466
no puedo decir donde RN ya que no está definido aún.

115
00:07:04,483 --> 00:07:07,466
RA la derecha? Por lo que voy a decir, bueno, donde el número de fila bla es igual a 1, 

116
00:07:09,166 --> 00:07:11,466
bien, me de un error.

117
00:07:11,483 --> 00:07:12,466
>> Si.

118
00:07:12,483 --> 00:07:15,183
¿Por qué? Bien, porque funciona la fila número en todas estas funciones de clasificación 

119
00:07:15,266 --> 00:07:18,466
y agregado...  o, lo siento, todos estos ranking, que se

120
00:07:18,483 --> 00:07:23,466
calculan cuando seleccione. ¿Verdad? Por lo que en las cargas de trabajo,
121
00:07:23,483 --> 00:07:27,250
no tenemos idea lo que significa este número de la fila porque obviamente si 

122
00:07:27,333 --> 00:07:29,466
cambio el donde cláusula y si digo donde...

123
00:07:30,483 --> 00:07:33,400
oohh. Dedos gordos.

124
00:07:33,483 --> 00:07:34,466
>> Sentía que uno.

125
00:07:34,483 --> 00:07:40,466
>> Si ahora digo guarda el identificador de pedido es de menos de 1 mil, que formaría

126
00:07:40,483 --> 00:07:42,466
formaría parte de la consulta y ahora los números de fila cambiar, ¿verdad?

127
00:07:43,483 --> 00:07:46,466
Está basados en este número. Así que ¿qué puedo hacer

128
00:07:46,483 --> 00:07:50,466
en cambio puedo decir Inicio seleccionar de este conjunto 

129
00:07:52,483 --> 00:07:58,466
y ahora RN existe, verdad? Así que ahora puedo decir donde RN es igual a 1.

130
00:07:58,483 --> 00:08:02,466
Entonces, ¿qué significa esto? Bueno, esto significa obtener todos los pedidos,

131
00:08:02,483 --> 00:08:07,466
calcular el número de fila para cada pedido por el cliente, a la derecha,

132
00:08:07,483 --> 00:08:10,466
y luego me dan sólo el primero. Así que esto significa me da sólo 

133
00:08:11,0 --> 00:08:13,466
la primera orden de cada cliente.

134
00:08:16,483 --> 00:08:18,466
Y ahora debo pasar este número que podemos ver aquí abajo en la 

135
00:08:18,483 --> 00:08:21,466
esquina inferior derecha, 19.119 filas.

136
00:08:21,483 --> 00:08:22,466
>> Verdad.

137
00:08:22,483 --> 00:08:25,466
>> Así que es una cosa interesante de esto.

138
00:08:26,483 --> 00:08:31,466
Uno es usando la ventana funciones, números de fila en este caso así como 

139
00:08:31,483 --> 00:08:34,466
qué significa esta cosa y lo que puede lograr.

140
00:08:34,483 --> 00:08:37,383
Así que mucho depende de lo que buscas, si desea 

141
00:08:37,466 --> 00:08:41,416
utilizar distintos, contar distinción, o algo como el número de fila 

142
00:08:41,483 --> 00:08:45,466
para agarrar las últimas órdenes. Digamos que quería obtener todos los pedidos

143
00:08:45,483 --> 00:08:48,466
que se realizan en el mismo día. Ahora, la fila número... Si se hacen

144
00:08:48,483 --> 00:08:51,466
en el mismo día, que tendrán números de fila diferentes, a la derecha,

145
00:08:51,216 --> 00:08:54,466
1 y luego 2, 3, 4, incluso si tienen el mismo valor y al azar 

146
00:08:55,483 --> 00:08:59,466
en el orden los encontramos. Pero si quiero decir fila, ahora me gustaría

147
00:08:59,183 --> 00:09:03,466
conseguir múltiples órdenes... filas porque voy a por todas...

148
00:09:03,483 --> 00:09:06,466
todas las órdenes que tienen la misma fecha de la orden se

149
00:09:06,483 --> 00:09:10,466
se volverá con el mismo rango. Para el rango 1 ahora pueden ser varios pedidos.

150
00:09:10,483 --> 00:09:13,466
Y en este caso... veamos si existe este caso. Sí. 

151
00:09:13,483 --> 00:09:15,433
Así que ahora tengo algunos de ellos están en el mismo día.

152
00:09:15,450 --> 00:09:15,466
>> Si.

153
00:09:16,483 --> 00:09:18,466
>> Así 19,127 filas atrás.

154
00:09:19,483 --> 00:09:20,466
>> Muy bien.

155
00:09:22,483 --> 00:09:25,466
Muy bien. Por tanto conseguimos el grupo por y cláusula que tiene 

156
00:09:25,483 --> 00:09:28,466
con la cual vamos a trabajar. Y esto va a ser tipo de...

157
00:09:28,483 --> 00:09:31,466
una vez más, estamos trabajando con las funciones de agregado y formas

158
00:09:31,483 --> 00:09:35,216
para crear datos de Resumen y obtener los datos de resumen. Así que

159
00:09:35,300 --> 00:09:39,466
vamos a seguir hablando sobre el grupo y el haber.

160
00:09:39,483 --> 00:09:42,333
Habiendo, SELECT y ORDER BY debe... deben devolver un 

161
00:09:42,416 --> 00:09:45,466
valor único por grupo. Todas las columnas en este select, tienen, un Orden By

162
00:09:45,483 --> 00:09:47,466
tiene que aparecer en el grupo por cláusula. Así tienes que ser consciente

163
00:09:47,483 --> 00:09:53,466
de ello. Si vas a utilizar una columna en el grupo por cláusula, 

164
00:09:54,483 --> 00:09:55,466
tiene... o en el... sí. Si vas a utilizar una columna

165
00:09:55,483 --> 00:09:57,466
en el grupo por cláusula, debe aparecen en el select, tener,

166
00:09:57,483 --> 00:09:58,466
u ordenar por.

167
00:09:59,483 --> 00:10:03,266
Por lo que tiene haber aparecido allí ya. Con el orden 

168
00:10:03,350 --> 00:10:04,466
lógico,  hemos pasado por esto ya hemos visto este un par de

169
00:10:05,483 --> 00:10:10,466
veces la realidad se procesa la declaración, la de,

170
00:10:10,483 --> 00:10:13,466
entonces el donde, el grupo por tener, hasta la selección 

171
00:10:13,483 --> 00:10:16,216
y orden por ser último. Es muy, muy importante para que usted 

172
00:10:16,300 --> 00:10:19,466
pueda entenderlo. Si usas el grupo por, todas las fases 

173
00:10:19,483 --> 00:10:22,466
posteriores funcionan en ese grupo, no de la fila de origen. Así que se va 

174
00:10:22,483 --> 00:10:26,300
a trabajar sobre la información del grupo. And that's why that order

175
00:10:26,383 --> 00:10:29,466
is important to understand here. This one here is actually just

176
00:10:29,483 --> 00:10:34,466
getting a count. It's going to display it as a count as the header

177
00:10:34,483 --> 00:10:37,466
for it. And we're going to group by customer ID. So we're trying

178
00:10:37,483 --> 00:10:40,466
to see how many customers that we have, we're going to group

179
00:10:40,483 --> 00:10:44,466
by customer ID. And then the second statement here, the aggregate

180
00:10:44,483 --> 00:10:47,466
function is going to refer to any columns, not just those in

181
00:10:47,483 --> 00:10:50,466
the group by clause. So we're going to select product ID, max

182
00:10:50,483 --> 00:10:55,266
order quantity as the largest order. So when we run this, we're

183
00:10:55,350 --> 00:10:58,466
going to group it by product ID. So for each product ID we're

184
00:10:58,483 --> 00:11:02,316
going to see the maximum number of items ordered per product.

185
00:11:02,400 --> 00:11:06,366
So this allows us to use that max aggregate function to be able

186
00:11:06,450 --> 00:11:08,433
to return that content to us.

187
00:11:09,333 --> 00:11:13,450
The having clause provides a search condition that every group

188
00:11:13,483 --> 00:11:17,466
in the group by clause must meet. And this is processed after

189
00:11:17,483 --> 00:11:20,466
the group by. So what we're going to do is we're going to select

190
00:11:20,483 --> 00:11:24,466
customer ID and we're going to do a count as count orders from

191
00:11:24,483 --> 00:11:28,466
the sales order header table. We're going to group by customer ID.

192
00:11:28,483 --> 00:11:30,466
And then we're going to say, oh, all those that are group by

193
00:11:30,483 --> 00:11:33,466
customer ID, once that group is created for each customer ID,

194
00:11:34,483 --> 00:11:37,466
having a count greater than 10, so if we have less than 10 we

195
00:11:37,483 --> 00:11:40,466
don't want to really see much about that customer, we want to

196
00:11:40,483 --> 00:11:44,466
see only those items that are returned to us, those rows returned

197
00:11:44,200 --> 00:11:48,466
to us in those groups, that are greater than 10. So we'll do

198
00:11:48,483 --> 00:11:51,466
a count on those customer IDs that are returned to us and then

199
00:11:51,483 --> 00:11:54,466
we'll return the result set with those items that have more than

200
00:11:54,483 --> 00:12:00,466
10 in that count return... the count orders field to be more

201
00:12:00,483 --> 00:12:01,466
specific here.

202
00:12:02,483 --> 00:12:05,466
If I want to compare... so we talked... the having and the where

203
00:12:05,483 --> 00:12:08,466
are similar, but what's... I want to compare the two. The where

204
00:12:08,483 --> 00:12:13,466
filters rows before the groups are created. The having filters

205
00:12:13,483 --> 00:12:16,466
are rows which controls how the groups are going to be passed

206
00:12:16,483 --> 00:12:20,466
to the next logical phase. So if we look at this, we're going

207
00:12:20,216 --> 00:12:23,466
to use a count expression in the having clause. And this is

208
00:12:23,483 --> 00:12:28,466
going to be useful to really provide a solution for common business problems.

209
00:12:28,483 --> 00:12:31,466
Because this is going to show only customers that have placed

210
00:12:31,483 --> 00:12:34,433
more than one order. So in this case here we're doing a select

211
00:12:34,483 --> 00:12:37,466
customer ID, we're going to do a count on that from the sales

212
00:12:37,483 --> 00:12:40,466
customer as customer. And then we're going to join that table

213
00:12:41,483 --> 00:12:44,383
and we're going to join that table to the sales order header.

214
00:12:44,483 --> 00:12:48,466
Then we're going to give it a table name, an alias. And then

215
00:12:48,483 --> 00:12:50,466
we're going to group by customer ID, but then, again, we want

216
00:12:50,483 --> 00:12:54,466
to only see the content where a customer has placed. We're going

217
00:12:54,483 --> 00:12:57,466
to see content for multiple columns, but we're going to see only

218
00:12:57,483 --> 00:13:02,466
the rows returned to us where a customer has more than one order

219
00:13:02,483 --> 00:13:07,466
that's been placed. So that's going to give us a situation to

220
00:13:07,216 --> 00:13:11,466
find who our repeat customers are. We could even take it up

221
00:13:11,483 --> 00:13:14,466
a notch and say I happen to have an account with more than equal

222
00:13:15,333 --> 00:13:18,466
to 10 customers. So again we're trying to see maybe at this point

223
00:13:18,483 --> 00:13:22,466
who our more popular customers are, our busier customers are,

224
00:13:22,483 --> 00:13:25,466
and we'll get that information returned to us by taking advantage

225
00:13:25,483 --> 00:13:27,466
of some of these statements that we're showing here.

226
00:13:29,483 --> 00:13:32,466
So the group by and having clause, is there another... we kind

227
00:13:32,483 --> 00:13:35,466
of just did that one. Is there another demo on the group by and

228
00:13:35,483 --> 00:13:39,200
having we want to take a peek at? That's... I mean, the last

229
00:13:39,283 --> 00:13:40,466
one was pretty cool.

230
00:13:41,166 --> 00:13:43,466
If there's anything specific that you wanted to show us. If not,

231
00:13:43,483 --> 00:13:44,466
we'll just move on.

232
00:13:45,483 --> 00:13:46,466
>> No, I think we're fine.

233
00:13:46,483 --> 00:13:49,183
>> Okay. We're good. All right. Let's talk subquery.

234
00:13:49,266 --> 00:13:52,383
Subqueries could often be a little bit confusing because you're

235
00:13:52,466 --> 00:13:55,333
looking at the query within a query. So with the subqueries

236
00:13:55,416 --> 00:13:58,333
we have to be careful and aware of how they work, and there's

237
00:13:58,483 --> 00:14:01,466
a few different flavors of subqueries that we have associated

238
00:14:01,483 --> 00:14:05,466
with this. So the really nasty queries, so as I mentioned queries

239
00:14:05,200 --> 00:14:09,466
within queries, the results from the nested query are passed

240
00:14:10,483 --> 00:14:13,466
to the outer query. So the inner query acts like an expression

241
00:14:14,466 --> 00:14:17,216
that's going to be returned and used by the outer query.

242
00:14:17,300 --> 00:14:21,466
The subqueries can be self-contained or correlated where self-contained

243
00:14:21,483 --> 00:14:25,466
has no dependency on the out query, outer query. The correlated

244
00:14:25,483 --> 00:14:28,466
subqueries depend on the values from the outer queries.

245
00:14:29,266 --> 00:14:34,466
Subqueries can be either scale or multi... multi-valued or table valued.

246
00:14:34,483 --> 00:14:37,266
So we'll take a look at a scalar subquery here. We're going

247
00:14:37,350 --> 00:14:41,466
to do a select order ID, product ID, unit price, order quantity.

248
00:14:41,483 --> 00:14:43,466
From, the orders detail.

249
00:14:43,483 --> 00:14:47,466
Where, the sales order ID equal. Now we're going to use the

250
00:14:47,483 --> 00:14:50,466
subquery select max sales order ID. And we'll return that in

251
00:14:51,483 --> 00:14:54,466
the column called last order. And we're going to get this information

252
00:14:54,483 --> 00:14:58,333
from the sales order header. So what this is going to do, it's

253
00:14:58,416 --> 00:15:02,466
going to query the sales order header, it's going to look for

254
00:15:02,483 --> 00:15:07,333
the max... aggregate function max for a sales order ID. And it's

255
00:15:07,483 --> 00:15:09,466
going to return that as the last order.

256
00:15:10,250 --> 00:15:13,266
And we're going to go see what information on the last order

257
00:15:13,350 --> 00:15:14,466
that was just processed.

258
00:15:15,483 --> 00:15:17,466
And as you can see from... so additional information, if the

259
00:15:17,483 --> 00:15:20,466
interquery returns an empty set, the results can be converted

260
00:15:20,483 --> 00:15:24,466
to null. And the construction of the outer query determines whether

261
00:15:24,183 --> 00:15:28,466
the inner query is going to return that single value. So we

262
00:15:28,483 --> 00:15:31,466
actually have that with sales order ID, product ID, unit price

263
00:15:31,483 --> 00:15:35,466
and order quantity. Where, sales order ID equal. And then we

264
00:15:35,483 --> 00:15:38,383
have the subquery which is going to return and determine what

265
00:15:38,466 --> 00:15:42,466
that sales order ID is so it can process that order ID.

266
00:15:44,483 --> 00:15:47,466
Now, with multi-valued subqueries... this one's a little off

267
00:15:47,483 --> 00:15:51,466
keel here... the multi-valued subquery returns multiple values

268
00:15:51,183 --> 00:15:53,466
as a single column set. So what we're going to do is we're going

269
00:15:53,483 --> 00:15:57,383
to use the in clause here. We're going to go and query the sales

270
00:15:57,466 --> 00:15:58,466
order header.

271
00:15:58,483 --> 00:16:02,466
We're customer ID in. Well, in what? Well, we're going to perform

272
00:16:02,483 --> 00:16:06,283
another select statement. Select customer ID from sales.customer

273
00:16:06,416 --> 00:16:10,466
where territory ID equal 10. So now we're going to return content

274
00:16:10,483 --> 00:16:15,466
or the outer query will be performed based on the idea of what

275
00:16:15,483 --> 00:16:19,466
customer ID or territory ID equal 10. So it's going to return

276
00:16:20,0 --> 00:16:26,316
that content for us or perform that query for us based on that subquery.

277
00:16:28,483 --> 00:16:31,466
The keyword exist also could be used or not exist as you can

278
00:16:31,483 --> 00:16:35,466
see here. This is select customer ID and person ID. From, the

279
00:16:35,483 --> 00:16:39,466
sales customer. And we're going to rename that as cust.

280
00:16:40,483 --> 00:16:41,400
Where, exist.

281
00:16:42,483 --> 00:16:44,200
What exists? Well, we're going to do a select asterisk, so we

282
00:16:44,283 --> 00:16:46,466
can't use column names when we're using the exist. We have to

283
00:16:46,483 --> 00:16:54,466
use the actual... the asterisk or return all columns. From, sales.salesorderheader

284
00:16:54,483 --> 00:17:01,233
as ord, so for order. Where, cust.customer ID equal order.customer ID.

285
00:17:01,316 --> 00:17:04,466
So we're going to do a match on customer ID from the two tables

286
00:17:05,483 --> 00:17:08,200
in the subquery. If it exists, then we're going to return that

287
00:17:08,283 --> 00:17:11,466
content to the outer query and that content will be displayed.

288
00:17:11,483 --> 00:17:14,466
The customer ID specifically and a person ID will display it

289
00:17:14,483 --> 00:17:17,283
that way. And we're going to flip that around and do a not exist

290
00:17:17,366 --> 00:17:17,466
as well.

291
00:17:18,483 --> 00:17:22,466
And both of these will provide us information regarding the exist

292
00:17:22,483 --> 00:17:26,466
or regarding the content that's returned from within that query

293
00:17:26,483 --> 00:17:31,466
or that subquery. All right. Demo using subqueries.

294
00:17:31,483 --> 00:17:38,466
Let's jump out here and take a look at just a couple of those

295
00:17:39,483 --> 00:17:40,466
items that we just looked at.

296
00:17:45,483 --> 00:17:47,466
We'll jump back into SQL Management Studio.

297
00:17:47,483 --> 00:17:49,466
Module 4. I've got to close this out here.

298
00:17:51,483 --> 00:17:54,466
And let's open up one of my other items here.

299
00:17:57,483 --> 00:18:00,466
And so here's a couple items here. So this uses that...

300
00:18:00,483 --> 00:18:03,466
the one that's shown that uses several of those different, it

301
00:18:04,483 --> 00:18:07,466
has the count, the average, the min and max, so we can execute

302
00:18:07,483 --> 00:18:11,450
that here, and you'll see it comes back with unique orders, 31,465

303
00:18:11,483 --> 00:18:15,466
average price. Min order quantity is 1. And the max line total

304
00:18:15,483 --> 00:18:19,0
for a particular order was 27,893.

305
00:18:20,483 --> 00:18:24,466
This one will return the all customers and unique customers for

306
00:18:24,483 --> 00:18:28,466
a salesperson. We saw the... we saw the text for it or the command

307
00:18:28,483 --> 00:18:32,466
for it. I just want to execute it so you see the results for it.

308
00:18:32,483 --> 00:18:35,366
So salesperson ID, we have a few null values. But salesperson

309
00:18:35,450 --> 00:18:41,466
ID 274 in the year 2007 had 14 customers; 13 of them were unique.

310
00:18:41,483 --> 00:18:46,283
2006 had 20 customers; all of them were unique. And same with

311
00:18:46,366 --> 00:18:52,466
2008 and 2005. And, again, we order these by salesperson ID so

312
00:18:52,233 --> 00:18:54,466
we can see how each salesperson is doing.

313
00:18:55,483 --> 00:18:58,466
This here shows us a count of all customers and then sorts them

314
00:18:58,483 --> 00:18:59,466
by salesperson.

315
00:19:01,333 --> 00:19:04,466
So we'll execute that. Here's the salesperson ID. So salesperson

316
00:19:04,483 --> 00:19:10,466
ID 274 has 48 total customers. 275 has 450 total customers.

317
00:19:10,483 --> 00:19:13,466
So this kind of gives us a quick count on how our salespeople

318
00:19:14,400 --> 00:19:18,466
are doing and we can compare that to taking a look at the number

319
00:19:18,483 --> 00:19:20,433
of customers that they have.

320
00:19:21,400 --> 00:19:25,466
Here's the group by the having clause that we saw an example of.

321
00:19:26,300 --> 00:19:28,466
We'll go ahead and execute that. Here's the customer ID.

322
00:19:29,483 --> 00:19:32,466
And we're ordering it by count orders instead, so customer ID

323
00:19:32,483 --> 00:19:37,466
11091 has 20 orders that we have and we're just doing the count.

324
00:19:37,483 --> 00:19:39,466
And we're only looking for those items greater than 10.

325
00:19:39,483 --> 00:19:43,466
Again, we're looking for our most... our more popular customers,

326
00:19:43,483 --> 00:19:46,466
the ones that have at least 10 orders in this particular situation

327
00:19:46,483 --> 00:19:47,466
right here.

328
00:19:50,200 --> 00:19:52,466
Here's the information, returns information about the last order

329
00:19:52,483 --> 00:19:54,466
that was submitted. We saw the query for this. We're going to

330
00:19:54,483 --> 00:19:55,466
execute this now.

331
00:19:57,483 --> 00:20:01,466
And they're saying the sales order ID 75123 was the last order

332
00:20:01,483 --> 00:20:04,466
that was submitted. There were three products that it ordered.

333
00:20:04,483 --> 00:20:10,466
The unit price of each of them was 21.98, 159, and 8.99, and

334
00:20:10,483 --> 00:20:14,466
they ordered one item. So this is the last order that was submitted by...

335
00:20:15,300 --> 00:20:19,466
with... and the sales order ID was 75123. They ordered three

336
00:20:19,483 --> 00:20:23,466
different products. The price for those products and the quantity

337
00:20:24,483 --> 00:20:27,466
of those products that they ordered. Didn't spend a lot of money

338
00:20:27,483 --> 00:20:28,466
there unfortunately.

339
00:20:30,216 --> 00:20:32,316
This one's going to return all the sales orders for each customer

340
00:20:32,400 --> 00:20:36,166
in territory 10. So now we're going to narrow it down to a specific territory.

341
00:20:36,250 --> 00:20:38,466
We want to see what's going on in a specific territory maybe

342
00:20:38,483 --> 00:20:41,433
with a sales manager in that territory.

343
00:20:41,483 --> 00:20:48,466
So customer ID 20042 has a sales order ID, 43708. Supposed to

344
00:20:48,483 --> 00:20:51,466
return information. We could add additional information here.

345
00:20:51,483 --> 00:20:54,466
Notice it's returning 3200 rows.

346
00:20:55,483 --> 00:20:58,466
And so this would give us information about... specifically about

347
00:20:58,483 --> 00:21:02,466
a territory. In this case here, territory ID No. 10, we're going

348
00:21:02,483 --> 00:21:06,166
to look at each customer and each sales order ID associated with

349
00:21:06,250 --> 00:21:09,183
each customer to find out what kind of activity is taking place

350
00:21:09,266 --> 00:21:13,466
in territory No. 10 and only in territory No. 10. And, again,

351
00:21:13,483 --> 00:21:15,466
we could have swapped that out and used additional territories

352
00:21:16,450 --> 00:21:18,466
by changing that clause up there.

353
00:21:19,483 --> 00:21:22,466
This is going to display the person ID for every customer who

354
00:21:22,483 --> 00:21:25,466
has placed an order. This is that exist clause. And we'll go

355
00:21:25,483 --> 00:21:30,466
ahead and execute that. So customer ID 1100, the person ID was 13531.

356
00:21:31,483 --> 00:21:34,466
So every person, this is the person ID associated with the customer

357
00:21:34,483 --> 00:21:38,466
ID for each customer that has placed an order. The exists as

358
00:21:38,483 --> 00:21:42,466
and order had to be placed. So a record has to exist in the sales

359
00:21:42,483 --> 00:21:47,333
order header number... or table in order for them to be returned here.

360
00:21:47,483 --> 00:21:50,316
And you'll see we have 19,000 rows available for that.

361
00:21:52,166 --> 00:21:56,466
And that's getting ahead to the next section. So this is different

362
00:21:56,483 --> 00:22:00,466
ways for us to be able to query content. Specifically we're

363
00:22:00,483 --> 00:22:02,466
trying to use content that is a subquery.

364
00:22:02,483 --> 00:22:06,466
>> Oh, Brian, Brian, Brian. Can I show a demo?

365
00:22:06,483 --> 00:22:10,466
>> Yes, absolutely you could show a demo. In fact, the demo slide's

366
00:22:10,483 --> 00:22:11,233
up just for you.

367
00:22:11,316 --> 00:22:14,466
>> Oh. Wonderful. Okay. So I was just sitting here tinkering and

368
00:22:14,483 --> 00:22:16,433
thinking, so I thought maybe we should show something.

369
00:22:16,450 --> 00:22:16,466
>> That'd be nice.

370
00:22:16,483 --> 00:22:19,466
>> And also looking at the... some questions being asked. So I

371
00:22:19,483 --> 00:22:23,466
wanted to just show this example of derived table and what we

372
00:22:23,483 --> 00:22:26,466
also call common table expressions that can be super useful.

373
00:22:27,483 --> 00:22:30,400
So actually let's just take the example that I showed before

374
00:22:30,483 --> 00:22:35,466
with row number. So we can just start with that and just copy

375
00:22:35,483 --> 00:22:41,466
this thing over. So, again, this is called derived table.

376
00:22:41,200 --> 00:22:45,466
So basically it's a set that you query from. So you use the

377
00:22:45,200 --> 00:22:48,466
subquery in the from clause or the join clause for that matter.

378
00:22:48,483 --> 00:22:53,466
So you can say select from a table inner join, left join, derive table.

379
00:22:53,483 --> 00:22:55,333
That works perfectly.

380
00:22:56,283 --> 00:23:02,466
And in this case this was practical for us to figure out the...

381
00:23:02,483 --> 00:23:04,466
get us these orders based on

382
00:23:06,483 --> 00:23:09,466
the first order for each customer. There is another way of writing

383
00:23:09,483 --> 00:23:14,466
this, which is also very useful, which is using a common table expression.

384
00:23:14,483 --> 00:23:18,466
But the problem a little bit with this is if you write a big

385
00:23:18,233 --> 00:23:21,466
query, now you can imagine how it can look something...

386
00:23:21,483 --> 00:23:23,466
something like this, right?

387
00:23:26,483 --> 00:23:27,466
>> Pretty complex.

388
00:23:27,483 --> 00:23:31,466
>> Exactly. So if you're trying to make sense of it, that can

389
00:23:31,483 --> 00:23:35,466
be somewhat tricky, right? So instead of doing that, you can

390
00:23:35,483 --> 00:23:40,466
use this common table expression thing. So in that you declare

391
00:23:40,483 --> 00:23:43,466
these views, if you will, or derive tables or common table expressions first.

392
00:23:44,483 --> 00:23:49,466
So I can say with A as, this is my set called A, and I can just

393
00:23:49,483 --> 00:23:53,466
copy this, then... this thing in there, and now I have A available

394
00:23:53,483 --> 00:23:57,250
to me. And then I can do my select star from A. And where?

395
00:23:57,483 --> 00:24:01,466
Row number's equal to 1 or rank in this case since I'm using rank.

396
00:24:02,483 --> 00:24:04,466
And it's exactly the same thing. There's no performance difference

397
00:24:04,483 --> 00:24:08,466
or anything like that. But you can imagine now if I have a lot

398
00:24:08,483 --> 00:24:09,466
of these, right,

399
00:24:11,483 --> 00:24:13,466
you would have something that looks like this. And with commas

400
00:24:13,483 --> 00:24:17,466
up here just separating the sets, now my query itself is pretty simple.

401
00:24:17,483 --> 00:24:21,466
I would, okay, I will join, you know, A with B or something and

402
00:24:21,483 --> 00:24:25,450
then I will do left to go in this with this other thing. So becomes

403
00:24:25,483 --> 00:24:28,466
a lot easier to follow the logic of the query if you write it

404
00:24:28,483 --> 00:24:31,466
like this rather than as a derive table.

405
00:24:31,483 --> 00:24:39,466
And so let me show you an example also of this with group by.

406
00:24:39,483 --> 00:24:42,466
So let's say I want to

407
00:24:44,483 --> 00:24:49,316
calculate just orders...

408
00:24:49,483 --> 00:24:53,466
number of orders per customer, this very simple thing. So customer

409
00:24:53,233 --> 00:25:01,466
ID comma sum... or, sorry, just count star. So just number of

410
00:25:02,0 --> 00:25:03,300
orders per customer.

411
00:25:13,483 --> 00:25:14,466
Sales order header.

412
00:25:16,333 --> 00:25:20,466
Group by customer ID. Okay. So I have this query.

413
00:25:21,483 --> 00:25:26,400
Now let's say I want to do something actually a little bit different.

414
00:25:26,483 --> 00:25:29,466
Instead of using customer ID, I would like these grouped by

415
00:25:31,166 --> 00:25:32,466
a calculation instead.

416
00:25:32,483 --> 00:25:38,466
So tie these together. So this is something I typically do is

417
00:25:38,483 --> 00:25:42,166
I often forget what the columns are. So I can just do this and

418
00:25:42,483 --> 00:25:46,466
now I'll easily find the column. So let's say we say, okay,

419
00:25:46,483 --> 00:25:51,466
status 5 is okay and all other statuses address are not okay.

420
00:25:51,483 --> 00:25:57,466
So in that case I'll say something like case when status is equal

421
00:25:57,483 --> 00:26:00,466
to 5, then I want to return okay.

422
00:26:01,400 --> 00:26:03,400
Else I'll say not okay.

423
00:26:04,166 --> 00:26:08,466
Right? End as status.

424
00:26:09,483 --> 00:26:13,466
And since this is grouped by, I now need to go and group by exactly

425
00:26:14,0 --> 00:26:15,466
this full clause, right?

426
00:26:16,483 --> 00:26:18,466
So I need to put that there as well.

427
00:26:19,166 --> 00:26:22,466
Because, again, this column alias status isn't available in the

428
00:26:22,483 --> 00:26:25,466
group by clause because this is really what we're typing, right?

429
00:26:27,166 --> 00:26:31,466
Logically we're starting from then comes group by and then select.

430
00:26:32,483 --> 00:26:33,466
So I'll go and execute this.

431
00:26:34,483 --> 00:26:37,466
You can see it works nice... well, okay, we don't have anything locked.

432
00:26:38,483 --> 00:26:42,416
This status seems super useful, so let's not use that.

433
00:26:46,483 --> 00:26:52,283
Let's use revision number instead just for the example.

434
00:27:01,483 --> 00:27:11,466
Okay. Oh, sorry, is equal to 3. Ah. There we go. Okay and sum

435
00:27:11,483 --> 00:27:15,466
not okay. Now, this is officially somewhat irritating that you

436
00:27:15,483 --> 00:27:17,466
are to repeat the case expression.

437
00:27:18,266 --> 00:27:21,266
But with a derived table... common table expression I don't need to.

438
00:27:21,350 --> 00:27:25,333
I can say with A as I define the expression

439
00:27:26,483 --> 00:27:27,466
and then

440
00:27:32,483 --> 00:27:35,200
I don't have the count here anymore. This is just my...

441
00:27:35,283 --> 00:27:38,466
this is the full set that I need, right, so I can do a select

442
00:27:38,483 --> 00:27:39,400
star from A,

443
00:27:42,483 --> 00:27:46,466
which works fine. I get all of the rows back. And now...

444
00:27:46,483 --> 00:27:49,466
obviously now status is a normal column. Right? So now I can

445
00:27:49,483 --> 00:27:55,466
just say, okay, from a group by status, and I would like to get

446
00:27:55,216 --> 00:27:58,466
the status and I want the count.

447
00:28:03,483 --> 00:28:08,316
And now this works fine. Right? So these common table expressions

448
00:28:08,400 --> 00:28:12,466
or derived tables can greatly help you simplify your queries.

449
00:28:12,483 --> 00:28:16,466
Now you may ask, oh, isn't this less performant because clearly

450
00:28:16,483 --> 00:28:21,450
we'll generate this full set and then you'll go ahead and basically

451
00:28:21,483 --> 00:28:24,466
do the calculation on top of this. So what we do in the query

452
00:28:24,483 --> 00:28:28,450
optimization is we... one of the big first steps we do is flatten

453
00:28:28,483 --> 00:28:32,466
the query. So it's not always the case, but, typically, however

454
00:28:32,483 --> 00:28:36,466
you write it through a view derived tabled common table expression,

455
00:28:36,483 --> 00:28:40,466
when it hits the query optimizer, it's just like the flat query

456
00:28:40,483 --> 00:28:43,333
that you would have written directly against the table with none

457
00:28:43,483 --> 00:28:45,466
of these. So they shouldn't actually affect performance.

458
00:28:48,483 --> 00:28:51,466
>> All right. Excellent. Thanks very much, Tobias, for explaining

459
00:28:51,483 --> 00:28:54,466
that for us. We're going to talk about some table functions and

460
00:28:54,483 --> 00:28:59,466
focus just on some of the details on using table functions.

461
00:28:59,183 --> 00:29:01,466
We're going to begin by talking about a sample view. And this

462
00:29:01,483 --> 00:29:04,466
is very simple. And, remember, a view is not an object that's

463
00:29:04,483 --> 00:29:08,466
stored in a database. It's role in object at... it's a query object.

464
00:29:08,483 --> 00:29:12,300
So when I go out and execute a statement, a select statement

465
00:29:12,383 --> 00:29:15,466
against a view, it's actually grabbing the information or retrieving

466
00:29:15,483 --> 00:29:19,466
the information from underlying tables as through this view.

467
00:29:19,166 --> 00:29:21,466
So we're going to create the view called humanresource.employee

468
00:29:21,483 --> 00:29:25,466
list as we're going to select four rows or four columns from

469
00:29:25,483 --> 00:29:28,466
the humanresources.employee, and then we can turn around and

470
00:29:28,483 --> 00:29:31,466
do a select asterisk from that employee list. So now I've got

471
00:29:31,483 --> 00:29:36,466
a view and I can restrict the view. So I may have 15, 20 columns

472
00:29:36,166 --> 00:29:39,466
in the employee lists, and there's probably only four or five

473
00:29:39,483 --> 00:29:42,466
I want some of my... or some individuals to see. But what I

474
00:29:42,483 --> 00:29:45,466
can do is create a view, give them permission to access the view,

475
00:29:45,483 --> 00:29:48,466
and the view will only return that content to them or those four

476
00:29:48,483 --> 00:29:51,466
rows that they have permissions that are displayed in the view

477
00:29:51,483 --> 00:29:56,0
that they have permissions to see. Now, this is showing an example

478
00:29:56,483 --> 00:29:58,416
of creating a view with just one underlying table. You could

479
00:29:58,483 --> 00:30:00,466
actually create a view with multiple underlying tables. We could

480
00:30:00,483 --> 00:30:04,466
use join statement and get information from the employee list

481
00:30:04,483 --> 00:30:07,466
and the employee address list if we wanted to. Or employee list,

482
00:30:07,483 --> 00:30:10,466
we want to see how many employees are also customers, have bought

483
00:30:10,483 --> 00:30:13,466
some of our product. So we could actually use a join statement

484
00:30:13,483 --> 00:30:17,466
here to make this a little bit more complex. But this view here

485
00:30:17,483 --> 00:30:19,466
is just going to take four columns from our employee...

486
00:30:19,483 --> 00:30:23,466
from our employee table and create a view of them. Now I can

487
00:30:23,483 --> 00:30:27,466
get permissions to individuals to access the view without giving

488
00:30:27,483 --> 00:30:31,466
them permissions to access the other columns within that...

489
00:30:31,483 --> 00:30:35,466
within that underlying table. And, again, I could add additional

490
00:30:35,483 --> 00:30:39,466
columns from other tables to ensure that my users are seeing...

491
00:30:39,483 --> 00:30:43,233
are able to see additional content in this view. And, again,

492
00:30:43,316 --> 00:30:45,466
they're not stored... it's not stored as an object, it's more

493
00:30:45,483 --> 00:30:49,466
of a query object here. The table value functions are created

494
00:30:49,483 --> 00:30:52,466
by administrators and developers. We can create a name, a function,

495
00:30:53,483 --> 00:30:55,466
using a create function here. We're creating a function here

496
00:30:55,483 --> 00:30:59,466
for a line total. We're going to pass a parameter called sales

497
00:30:59,483 --> 00:31:03,466
order ID. Notice that's what unique about this, it returns a

498
00:31:03,483 --> 00:31:08,466
type called table. So instead of a scalar function or a value

499
00:31:08,483 --> 00:31:11,466
or a group of values be returned, this actually returns a table.

500
00:31:12,483 --> 00:31:15,466
And then it uses as return, and there's a select statement in

501
00:31:15,483 --> 00:31:18,466
there, and it's going to actually use the cast to do a conversion

502
00:31:19,400 --> 00:31:23,466
and then it's going to create a field as decimal 8 comma 2, and

503
00:31:24,483 --> 00:31:26,466
it's going to grab the information sales order detail.

504
00:31:26,483 --> 00:31:31,450
Where, the sales order ID equal the path's variable, whatever

505
00:31:31,483 --> 00:31:34,466
we passed in for the sales order ID. So it's going to match

506
00:31:34,183 --> 00:31:37,466
it up and it's going to execute or perform this function based

507
00:31:37,483 --> 00:31:42,466
on the sales order ID and compare that in that where clause to

508
00:31:42,200 --> 00:31:44,433
perform that function.

509
00:31:46,483 --> 00:31:49,466
Derive tables are name query expressions created with an outer

510
00:31:49,483 --> 00:31:52,216
select statement. I think we just saw a good idea of those.

511
00:31:53,483 --> 00:31:57,466
Derived tables must have an alias, have names for all columns...

512
00:31:57,483 --> 00:32:00,466
every column has to have a name... have unique names for every

513
00:32:00,483 --> 00:32:05,466
column, are not used in an order by clause, and cannot be referred

514
00:32:05,483 --> 00:32:10,466
to multiple times in the same query. So a few ideas about how

515
00:32:10,483 --> 00:32:14,466
derived tables are used. They may be internal or external aliases

516
00:32:14,483 --> 00:32:17,466
or use internal or external aliases, they may refer to parameters

517
00:32:18,333 --> 00:32:22,466
and/or variables, and they may be nested within other derived tables.

518
00:32:22,483 --> 00:32:25,466
So there's some restrictions and there's some limitations or

519
00:32:25,483 --> 00:32:28,466
limitations that you can be... you should be aware of when you're

520
00:32:28,483 --> 00:32:32,466
looking at the use of these derived tables. We can pass arguments

521
00:32:32,483 --> 00:32:36,333
to derived tables. We're going to declare a variable here called

522
00:32:36,416 --> 00:32:41,450
emp ID of int time with 9. We're going to select order year.

523
00:32:41,483 --> 00:32:44,466
We're going to do a count distinct as customer count. And then

524
00:32:44,483 --> 00:32:48,466
we're going to perform the query. Select year as order date.

525
00:32:48,183 --> 00:32:50,466
And then... or select year... a portion of the order date as

526
00:32:50,483 --> 00:32:54,466
order year, customer ID, from the sales order table where emp

527
00:32:54,483 --> 00:32:58,466
ID equal to past emp ID with a declared variable. And we're

528
00:32:58,483 --> 00:33:01,466
going to set this up as a derived year. And then we're going

529
00:33:01,483 --> 00:33:04,466
to group this by order year. And this will give us information

530
00:33:04,483 --> 00:33:11,466
about the order year on the distinct customer IDs and the number

531
00:33:12,366 --> 00:33:17,466
of items that customers purchase for a particular year. And we're

532
00:33:17,483 --> 00:33:21,466
going to pass the ID of that customer in as a variable when we

533
00:33:21,483 --> 00:33:25,466
run this... or use this derived table.

534
00:33:26,466 --> 00:33:29,300
Now, the CTEs, or common table expressions, we just got a nice

535
00:33:29,383 --> 00:33:34,466
demo from Tobias on this. With CTE year as. We're going to select

536
00:33:34,483 --> 00:33:39,183
a year order date as order year, customer ID. And then we're

537
00:33:39,266 --> 00:33:41,466
going to go in, we're going to do a select order year with a

538
00:33:41,483 --> 00:33:45,466
count distinct customer ID as customer count. From the CTE year,

539
00:33:45,483 --> 00:33:48,466
which is what we decided... what we define, excuse me, with the

540
00:33:48,483 --> 00:33:52,466
with clause. And then we're going to group by the order year.

541
00:33:52,483 --> 00:33:55,466
So this allows us... and, again, this is the demo, this is an

542
00:33:55,483 --> 00:34:03,466
example of what Tobias just demoed for us just a few moments ago.

543
00:34:03,483 --> 00:34:05,466
Are there any other functions that you're interested in demoing

544
00:34:05,483 --> 00:34:07,466
in this particular module?

545
00:34:07,483 --> 00:34:10,433
>> I can go ahead and demo just the table valued functions.

546
00:34:10,450 --> 00:34:10,466
>> Okay.

547
00:34:10,483 --> 00:34:14,0
>> And talk a little bit about that. So basically why would you

548
00:34:14,483 --> 00:34:18,466
use a view versus a table valued function. And there are two

549
00:34:18,216 --> 00:34:20,383
types of table valued functions. There are the inline table

550
00:34:20,466 --> 00:34:24,166
valued that we shown on the slide, and you can also do multistatement

551
00:34:24,250 --> 00:34:27,466
table valued functions, which are a little bit more complex and

552
00:34:27,483 --> 00:34:31,466
you can use for somewhat different types of problems. But typically

553
00:34:31,483 --> 00:34:34,466
the table valued function, it's just a view. It's a view that

554
00:34:34,483 --> 00:34:38,466
takes parameters, really nothing else. So it's useful for you

555
00:34:38,483 --> 00:34:42,466
if you want to force queries to look a certain way. And it's

556
00:34:42,483 --> 00:34:46,316
fairly common that you want to say, well, if you search this

557
00:34:46,400 --> 00:34:49,466
table you really should search on dates because I have an index

558
00:34:49,483 --> 00:34:50,466
on dates.

559
00:34:51,483 --> 00:34:55,466
So as an example, we may say, okay, we want a function or a view

560
00:34:56,166 --> 00:34:59,466
that gives us just total purchases per customer, let's say.

561
00:35:01,483 --> 00:35:03,466
So let's just call this sales.fn

562
00:35:05,483 --> 00:35:07,466
customer sales.

563
00:35:08,483 --> 00:35:12,466
And we require you to take start date

564
00:35:14,483 --> 00:35:20,466
and end or pass and end date as parameters.

565
00:35:21,483 --> 00:35:26,466
We'll use the data type date. And returns table. Now, again,

566
00:35:26,483 --> 00:35:29,466
returns table doesn't mean we create some sort of table in some

567
00:35:29,483 --> 00:35:32,466
special way. It's no different from using a common table expression,

568
00:35:32,483 --> 00:35:34,466
a derived table or a view.

569
00:35:35,483 --> 00:35:39,466
As return and then we have this query. And originally this is

570
00:35:39,483 --> 00:35:42,466
now stored in metadata, so that's the big difference from using

571
00:35:42,483 --> 00:35:47,466
the inline to the CT or the derived table that now you have stored

572
00:35:47,483 --> 00:35:51,466
this so you can reuse it as much as you want. So we'll just

573
00:35:51,483 --> 00:35:53,466
do the simple thing of select customer ID...

574
00:35:57,483 --> 00:35:59,466
or customer ID comma...

575
00:35:59,483 --> 00:36:03,466
I think it's called company name.

576
00:36:04,333 --> 00:36:07,283
And then just say some of something.

577
00:36:11,366 --> 00:36:14,466
So from customer table, and then I'll do a left outer join.

578
00:36:14,483 --> 00:36:18,466
Because I want to include also customers that didn't buy anything.

579
00:36:18,483 --> 00:36:21,466
Sales.sales order header

580
00:36:23,483 --> 00:36:27,350
on sales order header...

581
00:36:27,483 --> 00:36:33,466
sorry, customer ID is equal to customer ID in the customer's table.

582
00:36:33,483 --> 00:36:37,466
And then I want to go and continue running into the sales order

583
00:36:37,483 --> 00:36:39,466
detail table to get the actual prize.

584
00:36:41,483 --> 00:36:47,466
So where sales order ID is equal to sales order ID. And then

585
00:36:47,483 --> 00:36:52,466
now I want to group this by the customer. So customer ID and

586
00:36:52,483 --> 00:36:55,466
I want it to include, okay, let's say a count number as well.

587
00:36:57,400 --> 00:36:58,466
And I want to sum the

588
00:37:01,450 --> 00:37:04,466
unit price, let's just say, as a simple example. And I want...

589
00:37:04,483 --> 00:37:08,466
if this happens to be... now, if we don't find... so if there

590
00:37:08,483 --> 00:37:09,466
are no orders,

591
00:37:11,333 --> 00:37:15,333
we'll get null returned, right, so the sum has nothing to sum up.

592
00:37:16,483 --> 00:37:20,466
Something weird going on here. Okay. So I'll just say if this

593
00:37:20,483 --> 00:37:24,466
returns null, I want to see a return as total sales.

594
00:37:24,483 --> 00:37:30,466
So we go ahead and create this function. Oh, sorry. And then

595
00:37:32,466 --> 00:37:36,466
we require this filtering. So where the order date

596
00:37:38,316 --> 00:37:40,466
is greater than or equal to

597
00:37:42,483 --> 00:37:51,466
my start date that I passed in, and order date is let's say less than...

598
00:37:52,483 --> 00:37:55,466
just to make it easy, end date. So end date is exclusive in this

599
00:37:55,483 --> 00:37:57,466
case, just for simplicity.

600
00:37:58,483 --> 00:38:02,466
So now obviously I force whoever is querying my function to go

601
00:38:02,483 --> 00:38:06,466
and use the order... if I have an order date index, presumably

602
00:38:06,483 --> 00:38:08,466
that can be used depending a little bit on what other indexes

603
00:38:08,483 --> 00:38:11,466
I have on the other two tables. But I'll create the function.

604
00:38:11,483 --> 00:38:23,466
Oops. Some unit price, oh, sales order ID. So it should be order date.

605
00:38:23,483 --> 00:38:25,466
It's hard to compare an integer with the date.

606
00:38:26,483 --> 00:38:30,283
So now we have the function, and now we can just go ahead and

607
00:38:30,366 --> 00:38:33,466
query and say, well, I would like to get everything from here

608
00:38:35,333 --> 00:38:45,466
and starting with 2011, January, and less than 2012, let's say.

609
00:38:46,483 --> 00:38:47,466
Or 2013.

610
00:38:52,483 --> 00:38:55,0
And there's nothing there, so let's go further back.

611
00:38:57,483 --> 00:39:02,383
There we go. So just an example of using an inline table valued function.

612
00:39:03,483 --> 00:39:05,466
>> How many keyboards do you go through in a week? A month?

613
00:39:05,483 --> 00:39:06,466
>> Well, I'll use this... I'm actually...

614
00:39:06,483 --> 00:39:09,466
>> I see that one smoking already. It's only been a few hours.

615
00:39:09,483 --> 00:39:12,466
>> The big problem here is... so this is... someone asked about...

616
00:39:12,483 --> 00:39:16,466
so this is... it's not integrated. It's part of... it's a separate keyboard.

617
00:39:16,483 --> 00:39:20,466
But every time I go to Sweden I always buy a Swedish keyboard,

618
00:39:20,216 --> 00:39:23,466
so I used to... I should have brought one here today, but I forgot.

619
00:39:23,483 --> 00:39:25,466
>> Well, I'm glad you didn't. Because if you're typing that fast

620
00:39:25,483 --> 00:39:28,466
on a U.S. keyboard, I can't imagine how fast you type on a Swede keyboard.

621
00:39:28,483 --> 00:39:30,466
>> Yeah, and it will also be...

622
00:39:30,483 --> 00:39:31,466
>> Fire extinguisher over by the keyboard?

623
00:39:32,166 --> 00:39:34,466
>> Yeah. I would say not select, but it's [Speaking Swedish].

624
00:39:35,366 --> 00:39:38,466
Yeah, it would be different.

625
00:39:38,483 --> 00:39:41,466
>> Well, you're doing great. Definitely. My hands are getting

626
00:39:41,483 --> 00:39:42,466
tired watching you type.

627
00:39:44,216 --> 00:39:46,266
All right. So let's just go ahead and do just a little bit of

628
00:39:46,350 --> 00:39:49,466
review for this module here. We introduce... so three of the

629
00:39:49,483 --> 00:39:53,466
common built-in aggregate function categories, the common, the

630
00:39:53,483 --> 00:39:57,466
statistical, and then the other category. We saw a demo on several

631
00:39:57,483 --> 00:40:01,466
of these as we went through, especially under the common ones

632
00:40:01,183 --> 00:40:03,466
on the other column. So we went through and saw some of these

633
00:40:04,483 --> 00:40:08,466
examples of these. We also talked about more detail on the distinct clause.

634
00:40:08,483 --> 00:40:12,466
We saw some information and detail about the group by and having clause.

635
00:40:12,483 --> 00:40:15,466
And we get some really good information on the demos when we

636
00:40:15,483 --> 00:40:20,466
did the scalar subqueries and multiple value subqueries.

637
00:40:21,483 --> 00:40:26,266
And then Tobias rocked with the table valued functions and the

638
00:40:26,350 --> 00:40:30,333
CTEs and the derived tables. Had some great... some demonstrations

639
00:40:30,416 --> 00:40:31,466
on those as well.

640
00:40:32,333 --> 00:40:35,466
And we also get to peek at how to create a function, one of these

641
00:40:35,483 --> 00:40:39,466
table valued functions and how can we use the return type of

642
00:40:39,483 --> 00:40:42,466
a table which is unique for something that we're... in comparison

643
00:40:42,483 --> 00:40:46,466
to what we normally use. So this is going to wrap up Module 4.

644
00:40:46,483 --> 00:40:50,466
And what we're going to do now is take a meal break. So here

645
00:40:50,483 --> 00:40:54,466
in Washington it is almost... it's about quarter to 12:00, so

646
00:40:54,183 --> 00:40:57,466
we'll return at about an hour from now. So we're going to take

647
00:40:57,483 --> 00:41:00,466
60 minutes, depending on what time zone you are in the world,

648
00:41:00,483 --> 00:41:04,466
60 minutes, roughly 60 minutes, 45 minutes past the next hour,

649
00:41:04,233 --> 00:41:04,466
wherever you may be.

650
00:41:04,483 --> 00:41:06,466
>> Wherever you are, it's still 60 minutes, right?

651
00:41:06,483 --> 00:41:09,466
>> It's still 60 minutes no matter where you are. So it doesn't

652
00:41:09,483 --> 00:41:11,466
matter where you are. It's always 60 minutes. So I don't know

653
00:41:12,333 --> 00:41:13,466
what the time frame is going to be on your clock, but...

654
00:41:13,483 --> 00:41:16,466
>> If it's not 60 minutes in Fahrenheit or there's something.

655
00:41:16,483 --> 00:41:19,166
>> No, it's not that way.

656
00:41:19,483 --> 00:41:21,350
>> No? Okay. Just checking.

657
00:41:21,433 --> 00:41:24,466
>> Regular time. Thank goodness. So all right. So eat up, drink

658
00:41:24,483 --> 00:41:27,466
up, recharge for this afternoon or remaining modules that we

659
00:41:27,483 --> 00:41:30,466
have, because it may not be afternoon for you. We'll be back

660
00:41:30,483 --> 00:41:34,466
in about 60 minutes, 45 minutes past the next hour, and we'll

661
00:41:34,483 --> 00:41:37,466
continue on with our discussion. We still have four great modules

662
00:41:37,483 --> 00:41:41,466
left for us to discuss later on today, and we look forward to

663
00:41:41,483 --> 00:41:44,466
seeing you back here in about 60 minutes. Thank you for joining us.

664
00:41:44,483 --> 00:41:47,466
>> Thank you.

